### 复习

#### 对线程

1、线程的基本特性：

多线程运行并发、并行执行（线程是CPU调度的最小单位）

线程的创建、销毁是比较耗时的；----->  线程池执行任务的优化方案

2、创建线程的方式：

继承Thread类

实现Runnable接口

通过FutureTask + Callable方式 ：可以获取线程执行结果

3、线程基本API

线程等待：线程对象.join()/join(long time)：阻塞当前线程（当前代码行所在的线程），等待线程对象执行完毕或是时间到了，满足一个条件往下执行

中断线程：

三个API：线程对象.interrupt()、Thread.interrupted()、线程对象.isinterrupted()

原理：都是通过中断标志位来操作

4、线程不安全的原因/线程的三大特性

原子性

可见性：主内存（线程共享区域）、工作内存（CPU高速缓存），主内存到工作内存的数据拷贝所带来的不安全

有序性：指令重排序造成的不安全。单个线程看自己内部的指令执行都是有序的，看其他线程都是无序的

5、解决方案

synchronized关键字：synchronized的理解/原理？

- ​	原理：monitor机制对对象加锁操作，让线程同步互斥

​				monitorenter----synchronized代码行

​				monitorexit----同步代码块/同步方法结束

​				计数器：1、可重入2、获取对象锁，计数器+1

- ​	锁优化：级别从上到下是由高到低的

  重量级锁：多个线程在同一个时间点竞争同一个对象锁。线程会在被唤醒状态与阻塞状态种不停的切换，性能比较差

  轻量级锁：常常发生在多个线程在不同的时间点/一个时间点只有一个线程，影响比重量级锁小，原理：CAS实现

  偏向锁：一个线程重入获取对象锁（已经获取了，再次获取时）

为什么有Lock体系的API，还要使用synchronized？１、synchronized优势２、举例，如ConcurrenHashMap１.７以及Lock实现，１.８以CAS＋synchronized实现

６、volatile关键字：

可见性

禁止指令重排序／建立内存屏障：volatile修饰在变量上，基于指令级别（分解指令），volatile修饰的变量所在的代码行，之前的代码不能重排序到之后,之后的代码不能重排序到之前.相当于在volatile这个指令建立的一个内存屏障,前后不能越界.

happeds-before原则(扩展了解)

单例模式:

- 目标:

​		编程题熟练编写线程安全的单例代码,  

​		面试中提问可能有: 有哪些单例模式的写法,线程安全版本的写法口头表述

- 写法:

​		非线程安全: 饿汉式, 懒汉式

​		线程安全: 双重校验锁+volatile修饰变量

​						  (了解) 静态内部类(类加载线程安全机制)    ,    枚举类

 8. 线程池

    优势 : 减少了线程创建/销毁的时间和性能上的消耗

    参数作用 (ThreadPoolExcutor快递公司):

    ​		核心线程数:正式员工的数量

    ​		最大线程数:正式员工+临时工的数量

    ​		3,4参数 : 空闲时间 , 临时工最大的空闲时间

    ​		阻塞队列 : 存放任务的仓库

    ​		拒绝策略 : 超过存放任务超出仓库的容量(阻塞队列的长度) 

    ​					CallaRunsPolicy:谁(调用execute/submit提交任务的线程)让我(快递公司)执行,我是拒绝执行任务,让你自己执行

    ​					AbortPolicy:拒绝执行,抛出异常

    ​					DisCardPolicy:丢弃最新的任务

    ​					DisCardOldestPolicy: 丢弃最老的任务

    创建线程的方式:			  

​						  new ThreadPoolExcutor

​						  Excutors.newXXX() 单线程 , 固定大小 , 缓存的 , 定时的

​		实现原理 : AQS

9. CAS

   乐观锁的一种实现 , 对线程自身修改值操作,始终保持一种乐观心态,预计能够很快的得到执行

   线程运行时自旋的方式(循环调用方法) , 通过原始值 , 修改值 , 预期值 , 版本号尝试设置值.

   ABA问题:没有版本号时,线程操作值的时候,预期值满足,但其实时其他线程修改过的(A-B-A).解决方案:引入版本号

   

10. AQS : 抽象的队列同步器

原理 : CAS(自旋的方式设置同步状态) , 虚拟的同步队列

juc包那些API以AQS来实现的 : 线程池 , CountDownLatch , Semaphore   

11. 高阶API

    Atomic原子性的并发包: AtomicInteger , AtomicLong , AtomicBoolean提供原子性的n++ , n--, !flag指令的线程安全的操作

    ​			原理 : CAS

    CountDownLatch/Semaphore : 线程间的等待 , 

    CountDownLatch:使用场景:等待所有线程执行完毕之后在执行指定代码

    Semaphore : 使用场景:多线程下,有限资源访问的情况

#### IO : 同步阻塞式的IO

缺点 : (了解)

​		1, 使用多线程造成的性能问题(如网络IO操作多个数据流)

​		2, CPU是轮询的方式调度线程 , 涉及线程上下文切换所带来的性能消耗

​		3, 线程阻塞到被唤醒运行 ,涉及用户态和内核态之间的切换, 比较消耗性能

​		4, 系统内存数据复制到JVM内存

#### 网络

OSI七层模型: 物理层, 数据链路层 , 网络层 , 传输层 ,  会话层, 表示层 , 应用层

TCP/IP五层或四层模型: 物理层 , 数据链路层 , 网络层 , 传输层 , 应用层.每一层的代表硬件, 协议/ 技术

网络传输流程(包含的协议, 技术, 相关网络设备做的事情---封装分用)

​	网络互联

​	局域网

​		交换机连接

​		交换机+路由器连接

​	广域网



TCP

​	特性

​	原理

UDP

​	特性

​	原理

HTTP

|            | 协议/技术                                        | 代表硬件                       | 补充             |               |
| ---------- | ------------------------------------------------ | :----------------------------- | ---------------- | ------------- |
| 物理层     | 0/1光电信号                                      | 网线 , wifi电磁波, 集线器(Hub) |                  |               |
| 数据链路层 | 以太网帧(里面包含了源MAC和目的MAC), ARP, MTU     | 交换机                         |                  | 绑定设备的mac |
| 网络层     | IP协议(包含了源IP,目的IP), 路由                  | 路由器                         | 主机:(系统+网卡) | 绑定ip        |
| 传输层     | TCP , UDP(包含了源端口号,目的端口号)             |                                | 主机: 系统       | 绑定端口      |
| 应用层     | HTTP , DNS , NAT, NAPT (了解:FTP , SMTP, Telnet) |                                | 主机: 应用程序   |               |



